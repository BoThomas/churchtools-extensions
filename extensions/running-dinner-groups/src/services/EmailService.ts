import type {
  EventMetadata,
  DinnerGroup,
  Route,
  GroupMember,
} from '@/types/models';
import type { CategoryValue } from '@churchtools-extensions/persistance';

export interface EmailContent {
  subject: string;
  htmlBody: string;
  textBody: string;
}

/**
 * Service for generating and sending email notifications
 */
export class EmailService {
  /**
   * Generate email content for route publication
   */
  generateRouteEmail(
    eventMetadata: EventMetadata,
    route: CategoryValue<Route>,
    dinnerGroup: CategoryValue<DinnerGroup>,
    allDinnerGroups: CategoryValue<DinnerGroup>[],
    members: GroupMember[],
  ): EmailContent {
    const groupMembers = members.filter((m) =>
      dinnerGroup.value.memberPersonIds.includes(m.personId),
    );

    // Get event name from group ID (would need to fetch from ChurchTools)
    const eventName = `Running Dinner Event`;

    const subject = `${eventName} - Your Route for Group ${dinnerGroup.value.groupNumber}`;

    // Generate HTML body
    let htmlBody = `
      <h2>${eventName}</h2>
      <h3>Your Group: #${dinnerGroup.value.groupNumber}</h3>

      <h4>Group Members:</h4>
      <ul>
    `;

    groupMembers.forEach((member) => {
      const name = `${member.person.firstName} ${member.person.lastName}`;
      const email = member.person.email || 'No email';
      const phone =
        member.person.phoneNumbers && member.person.phoneNumbers.length > 0
          ? member.person.phoneNumbers[0].phoneNumber
          : 'No phone';

      htmlBody += `<li><strong>${name}</strong><br>Email: ${email}<br>Phone: ${phone}</li>`;
    });

    htmlBody += `</ul>`;

    // Add route stops
    htmlBody += `<h3>Your Route:</h3>`;

    route.value.stops.forEach((stop, index) => {
      const hostGroup = allDinnerGroups.find(
        (g) => g.id === stop.hostDinnerGroupId,
      );
      if (!hostGroup) return;

      const hostPerson = members.find(
        (m) => m.personId === hostGroup.value.hostPersonId,
      );
      const hostName = hostPerson
        ? `${hostPerson.person.firstName} ${hostPerson.person.lastName}`
        : 'Unknown';

      const hostAddress = hostPerson?.person.addresses?.[0]
        ? `${hostPerson.person.addresses[0].street || ''}, ${hostPerson.person.addresses[0].zip || ''} ${hostPerson.person.addresses[0].city || ''}`
        : 'Address not provided';

      const mealName =
        stop.meal === 'starter'
          ? 'Starter'
          : stop.meal === 'mainCourse'
            ? 'Main Course'
            : 'Dessert';

      htmlBody += `
        <h4>${index + 1}. ${mealName} (${stop.startTime} - ${stop.endTime})</h4>
        <p>
          <strong>Host:</strong> ${hostName} (Group #${hostGroup.value.groupNumber})<br>
          <strong>Address:</strong> ${hostAddress}<br>
      `;

      // Add Google Maps link if address is available
      if (hostAddress !== 'Address not provided') {
        const encodedAddress = encodeURIComponent(hostAddress);
        htmlBody += `<a href="https://www.google.com/maps/search/?api=1&query=${encodedAddress}">View on Google Maps</a><br>`;
      }

      // Add dietary restrictions of guests at this stop
      // For simplicity, include all groups' dietary info
      const dietaryInfo: string[] = [];
      groupMembers.forEach((guest) => {
        if (guest.fields?.dietaryRestrictions) {
          dietaryInfo.push(
            `${guest.person.firstName}: ${guest.fields.dietaryRestrictions}`,
          );
        }
        if (guest.fields?.allergyInfo) {
          dietaryInfo.push(
            `${guest.person.firstName} (Allergy): ${guest.fields.allergyInfo}`,
          );
        }
      });

      if (dietaryInfo.length > 0) {
        htmlBody += `<strong>Dietary Notes:</strong><ul>`;
        dietaryInfo.forEach((info) => {
          htmlBody += `<li>${info}</li>`;
        });
        htmlBody += `</ul>`;
      }

      htmlBody += `</p>`;
    });

    // Add after party info if available
    if (eventMetadata.afterParty) {
      htmlBody += `
        <h3>After Party</h3>
        <p>
          <strong>Time:</strong> ${eventMetadata.afterParty.time}<br>
          <strong>Location:</strong> ${eventMetadata.afterParty.location}<br>
      `;
      if (eventMetadata.afterParty.description) {
        htmlBody += `<strong>Description:</strong> ${eventMetadata.afterParty.description}<br>`;
      }
      htmlBody += `</p>`;
    }

    htmlBody += `
      <hr>
      <p style="color: #666; font-size: 12px;">
        This email was generated by the Running Dinner Groups extension for ChurchTools.
      </p>
    `;

    // Generate plain text version
    let textBody = `${eventName}\n\n`;
    textBody += `Your Group: #${dinnerGroup.value.groupNumber}\n\n`;
    textBody += `Group Members:\n`;
    groupMembers.forEach((member) => {
      const name = `${member.person.firstName} ${member.person.lastName}`;
      const email = member.person.email || 'No email';
      const phone =
        member.person.phoneNumbers && member.person.phoneNumbers.length > 0
          ? member.person.phoneNumbers[0].phoneNumber
          : 'No phone';
      textBody += `- ${name}\n  Email: ${email}\n  Phone: ${phone}\n`;
    });

    textBody += `\nYour Route:\n`;
    route.value.stops.forEach((stop, index) => {
      const hostGroup = allDinnerGroups.find(
        (g) => g.id === stop.hostDinnerGroupId,
      );
      if (!hostGroup) return;

      const hostPerson = members.find(
        (m) => m.personId === hostGroup.value.hostPersonId,
      );
      const hostName = hostPerson
        ? `${hostPerson.person.firstName} ${hostPerson.person.lastName}`
        : 'Unknown';
      const hostAddress = hostPerson?.person.addresses?.[0]
        ? `${hostPerson.person.addresses[0].street || ''}, ${hostPerson.person.addresses[0].zip || ''} ${hostPerson.person.addresses[0].city || ''}`
        : 'Address not provided';

      const mealName =
        stop.meal === 'starter'
          ? 'Starter'
          : stop.meal === 'mainCourse'
            ? 'Main Course'
            : 'Dessert';
      textBody += `\n${index + 1}. ${mealName} (${stop.startTime} - ${stop.endTime})\n`;
      textBody += `   Host: ${hostName} (Group #${hostGroup.value.groupNumber})\n`;
      textBody += `   Address: ${hostAddress}\n`;
    });

    if (eventMetadata.afterParty) {
      textBody += `\nAfter Party:\n`;
      textBody += `Time: ${eventMetadata.afterParty.time}\n`;
      textBody += `Location: ${eventMetadata.afterParty.location}\n`;
      if (eventMetadata.afterParty.description) {
        textBody += `Description: ${eventMetadata.afterParty.description}\n`;
      }
    }

    return {
      subject,
      htmlBody,
      textBody,
    };
  }

  /**
   * Send email via ChurchTools email API
   * For MVP: console.log email content (actual sending to be implemented)
   */
  async sendEmail(
    recipientPersonIds: number[],
    subject: string,
    body: string,
  ): Promise<void> {
    // TODO: Implement actual email sending via ChurchTools API
    // For now, just log the email content
    console.log('=== EMAIL TO SEND ===');
    console.log('Recipients (Person IDs):', recipientPersonIds);
    console.log('Subject:', subject);
    console.log('Body:', body);
    console.log('=====================');

    // Simulate async operation
    await new Promise((resolve) => setTimeout(resolve, 100));
  }

  /**
   * Send route emails to all groups
   */
  async sendRouteEmails(
    eventMetadata: EventMetadata,
    routes: CategoryValue<Route>[],
    dinnerGroups: CategoryValue<DinnerGroup>[],
    members: GroupMember[],
  ): Promise<{ sent: number; failed: number; errors: string[] }> {
    const results = { sent: 0, failed: 0, errors: [] as string[] };

    for (const route of routes) {
      try {
        const dinnerGroup = dinnerGroups.find(
          (g) => g.id === route.value.dinnerGroupId,
        );
        if (!dinnerGroup) {
          results.failed++;
          results.errors.push(
            `Dinner group ${route.value.dinnerGroupId} not found`,
          );
          continue;
        }

        const emailContent = this.generateRouteEmail(
          eventMetadata,
          route,
          dinnerGroup,
          dinnerGroups,
          members,
        );

        await this.sendEmail(
          dinnerGroup.value.memberPersonIds,
          emailContent.subject,
          emailContent.htmlBody,
        );

        results.sent++;
      } catch (error) {
        results.failed++;
        results.errors.push(
          `Failed to send email for group ${route.value.dinnerGroupId}: ${error}`,
        );
      }
    }

    return results;
  }
}

// Export singleton instance
export const emailService = new EmailService();
